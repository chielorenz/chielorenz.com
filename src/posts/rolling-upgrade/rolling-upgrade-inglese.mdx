---
title: Rolling Upgrade™
excerpt: Or how we upgraded a 300k line PHP codebase while continuing the development of new features and bug fixing.
timestamp: 2024-05-14
published: true
---

import Image from "next/image";
import versionsSrc from "./symfony-versions.png";

# Rolling upgrade™

You find yourself in a small team, with four developers, having to meet the product roadmap deadlines, fix bugs, provide customer support, and update a 300k-line codebase without stopping everything. How do you do it?

To meet deadlines, we couldn’t assign more than one developer to work on the upgrade, and with just one person, the upgrade would take several weeks. Weeks during which the rest of the team would continue updating the codebase with new features and bug fixes, creating a hell of merge conflicts.

So, the idea was to bypass this problem entirely by automating the upgrade. I dedicated part of my time, around 30%, to writing a procedure capable of upgrading the codebase with a single click.

## The Codebase

But what kind of codebase was it? The backend of a web app, with 300k lines of code, written in PHP 5.6 with Symfony 2.7, that needed to be upgraded to PHP 8.1 with Symfony 6.4 (the latest versions at the time of the upgrade). The app handled database connections and migrations, generated Excel files, created PDFs, sent emails, managed image uploads, processed customer charges, uploaded files to S3, connected to SOAP servers, and much more. As you can imagine, the number of vendors used was anything but trivial.

## The Upgrade

Upgrading PHP was not particularly challenging: going from 5.6 to 8.1 meant skipping two major versions (PHP 6 doesn’t exist). The procedure only needed to ensure that the codebase didn’t use deprecated syntax. The real challenge was upgrading the vendors, which all needed to be updated to versions compatible with PHP 8.1.

The work involved reviewing all vendors, determining the correct versions to use, finding upgrade guides, and ensuring the procedure applied the required modifications. In some cases, the vendors were deprecated and hadn’t been updated for PHP 8.1 support. In those cases, we had to choose an alternative and ensure the procedure replaced the old library.

Upgrading Symfony was more complex. Despite the excellent documentation available for version upgrades, we faced numerous challenges, such as changes in folder structures and namespaces, configuration updates, the introduction of secrets, dependency injection via type-hinting, database migration system changes, and surely other issues my brain has conveniently forgotten as a defense mechanism.

Going from Symfony 2.7 to 6.4 meant four major versions and 16 minor ones:

<Image src={versionsSrc} alt="symfony versions" />

We went through the upgrade guides for all intermediate versions to understand their impact on our codebase and ensured that the procedure made the necessary modifications. These mainly involved new configurations, different folder structures, and new best practices that, while not strictly required, we decided to adopt anyway.

## The Procedure

The procedure consisted of a Bash script that cloned the codebase into a folder, copied the files into another folder using the new structure, and updated them using a mix of techniques such as regex, rsync, find, sed, and custom PHP scripts. Several Docker containers, created by the procedure itself, were used to execute composer commands and Symfony console commands. At each step, the procedure committed the changes to create checkpoints for debugging.

Here are some examples. This is a snippet of the Bash script:

```bash
log "Copy tests classes"
rsync -a "$S2_DIR/src/ApiBundle/Tests/Controller/" $S6_DIR/tests/Controller/
rsync -a "$S2_DIR/src/CoreBundle/Tests/Controller/" $S6_DIR/tests/Controller/
rsync -a "$S2_DIR/src/CoreBundle/Tests/Entity/" $S6_DIR/tests/Entity/
commit "ADD: Copy tests classes" $S6_DIR

log "Update entities"
find $S6_DIR/src/ $S6_DIR/tests/ $S6_DIR/config/ -type f -exec gsed -i -E -e 's/((Canvas|Api|Core|CRM|Cron|Desk|Export|Import|IncomeStatement|Migration)Bundle)\\+Entity/App\\Entity\\Core/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ $S6_DIR/config/ -type f -exec gsed -i -E -e 's/(Dashboard|Group|Integration)Bundle\\+Entity\\+Core/App\\Entity\\Core/g' {} +
commit "UPDATE: namespaces" $S6_DIR

log "Update entity manager injection to allow type-hintyng in services"
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/\$\bem\b/\$coreEm/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/->em\b/->coreEm/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/\$\bthis->em\b/\$this->coreEm/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/->get\("doctrine"\)->getManager\('"'"'access'"'"'\)/->get\('"'"'doctrine.orm.access_entity_manager'"'"'\)/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/->get\("doctrine"\)->getManager\('"'"'default'"'"'\)/->get\('"'"'doctrine.orm.core_entity_manager'"'"'\)/g' {} +
find $S6_DIR/src/ $S6_DIR/tests/ -type f -exec gsed -i -E -e 's/->get\('"'"'doctrine'"'"'\)->getManager\('"'"'default'"'"'\)/->get\('"'"'doctrine.orm.core_entity_manager'"'"'\)/g' {} +
commit "UPDATE: entity manager injection to allow type-hinting in services" $S6_DIR

log "Replace PHPExcel -> PhpSpreadsheet with rector"
docker exec upgrade-php-8 composer require --no-interaction --with-all-dependencies --working-dir=/var/www/api.s6 --dev rector/rector rector/rector-phpoffice
docker exec upgrade-php-8 /bin/ash -c "cd /var/www/api.s6/ && php bin/console cache:pool:clear cache.global_clearer" # clear cache
docker cp $CONFIG/rector.php upgrade-php-8:/var/www/api.s6/
docker cp $CONFIG/phpoffice upgrade-php-8:/var/www/api.s6/vendor
docker exec upgrade-php-8 /bin/ash -c "cd /var/www/api.s6/ && vendor/bin/rector process src"
docker exec upgrade-php-8 composer remove --no-interaction --with-all-dependencies --working-dir=/var/www/api.s6 --dev rector/rector rector/rector-phpoffice
commit "UPDATE: replace PHPExcel -> PhpSpreadsheet with rector" $S6_DIR
```

This is a snippet of a PHP script that updates controllers to work with the new dependency injection via type-hinting:

```php
...
// Find the class definition in the controller with a regex
// (use PREG_OFFSET_CAPTURE to get the match offset (in bytes))
$matchClass = '/class.*[\n\r]*{/';
preg_match($matchClass, $content, $matches, PREG_OFFSET_CAPTURE);
list($capture, $offset) = $matches[0];

$capturedLengh = strlen($capture); // lenght of the matched string
$insertPosition = $offset + $capturedLengh; // position where to insert the text
$parts = str_split($content, $insertPosition); // split the file content in the insert position
$beforeText = array_shift($parts); // this is the text befor the inset position
$afterText = implode($parts); // this is the text after the insert position

// Search all the container call like  $this->container->get(XXX) and extract the asked services.
$matchServices = '/\$this\s*->container\s*->get\(\s*(\'|")(?<service>[.\-\w]*)(\'|")\s*\)/';
preg_match_all($matchServices, $content, $matchedServices);
...
// The new text to intert
$glue = ",\n            "; // keep the spaces for indentation
$subscribers = implode($glue, $serviceDefinitions);
$newText = <<<EOF
    public static function getSubscribedServices(): array
    {
        return array_merge(parent::getSubscribedServices(), [{$subscribers}]);
    }
EOF;

// Join the final content and write it to the file
$newContent = $beforeText.$newText.$afterText;
$file = fopen($fullPath, "w");
fwrite($file, $newContent);
fclose($file);
...
```

By the end, the procedure consisted of a main Bash script with over 1,200 lines, hundreds of lines of PHP scripts, and YAML configuration files, totaling over 500 commits.

## The Upgrade Day

This was a job that took around 20 months, not weeks. Months. At a certain point, with enough testing and hope, we decided it was time to take the leap, so:

```bash
sh ./run.sh
# Several minutes of waiting, I don’t remember exactly how many
Done, checkout the codebase with Symfony 6.4 and PHP 8.1 in the $S6_DIR folder
```

We then took the entire folder generated by the procedure, replaced the old codebase while keeping the .git folder, and committed the changes—a commit that modified every single file in the codebase.

## Recap

It was not an easy task. At times, we wondered if we would ever finish, but we knew it had to be done, so we pushed through.

The decision to continue product development while writing a procedure to handle the upgrade proved to be a winning choice—perhaps even the only viable one in hindsight. The overhead of figuring out how to upgrade the codebase without doing it directly but by writing a procedure instead added significant complexity. However, it made the upgrade testable and repeatable.

After the upgrade, development accelerated. PHP 8.1 brought significant performance improvements, removing deprecated vendors made the codebase leaner, and adopting the latest Symfony version gave us access to several new tools.

## Lessons Learned

We realized that as a team, we could handle more complexity than we thought. We also learned that we had put ourselves in this situation by not keeping the codebase updated and that the effort to fix it was significantly greater than the effort needed to maintain it continuously.

Doing this upgrade I also learned many things, from unknown bash commands to how to read vendor upgrade guides, from how to manage a long task along with all the other necessary tasks to how not to give up on a task that seems to have no end but then, after 20 months, it ends.
